# OpenMP Monte Carlo — C++14 / Visual Studio 2022

> Лабораторная №5: параллельная оценка площадей и объёмов методом Монте‑Карло с использованием **OpenMP**. В проекте реализованы два кейса и проведена аналитика производительности: сравнение генераторов случайных чисел, влияния числа потоков, типа `schedule` и размера `chunk`.

## Что в проекте

- **Кейсы**
  - **Easy** — площадь круга через четверть круга (π-оценка).
  - **Normal** — объём октаэдра (через 1/8 октаэдра и масштабирование).
- **Параллелизация**: `#pragma omp parallel`, `#pragma omp for`, `atomic`, `reduction` (местами), измерение времени `omp_get_wtime()`.
- **ГСЧ для Монте‑Карло** (сравнение производительности и точности):
  - `rand()` / `srand()` (пер‑поточные сиды);
  - `<random>`: `mt19937` + `uniform_real_distribution` (double/float);
  - **LCG** (линейный конгруэнтный генератор) — собственная реализация.
- **Отчёт** с графиками/таблицами в `Зайцев_Захар_36_5.pdf`.
- **Цель аналитики** — получить практические выводы: как выбирать schedule, размер chunk и ГСЧ для максимальной скорости при приемлемой точности.

---

## Краткое описание реализации

- **Easy (круг):** для каждой точки `(x, y)` проверяется `x^2 + y^2 <= r^2` в четверти круга, результат умножается на 4.
- **Normal (октаэдр):** полу‑диагональ `diag` выводится из трёх точек; внутри 1/8 октаэдра условие `x + y + z <= 1` (после нормировки), затем масштабирование к полному объёму.
- **Параллелизм:** цикл сэмплинга распараллелен; у каждого потока локальный счётчик попаданий, суммирование через `atomic` (или `reduction`).
- **Измерения:** `omp_get_wtime()` вокруг вычислений; аргументы CLI управляют числом потоков.

---

## Итоги аналитики 

- **Лучший ГСЧ по скорости в Normal:** собственный **LCG** (в разы быстрее `rand()`/`mt19937`) при сопоставимой точности.
- **Schedule:** для равномерных по трудоёмкости итераций **`static`** даёт предсказуемое равномерное распределение; **`dynamic`** выигрывает при дисбалансе, но при слишком маленьком `chunk` растут накладные расходы.
- **Оптимальный `chunk` для `dynamic`:** эмпирически получена формула (ниже).
- **Число потоков:** ускорение растёт до количества аппаратных потоков CPU; далее — плато/регресс. Для 1 потока без OpenMP последовательная версия немного быстрее, чем `OMP` c `numThreads=1` (поверхностные накладные расходы).

<details>
<summary><strong>Сравнение ГСЧ (Normal, 8 потоков)</strong></summary>

| Метод                      | Время (локально) | Время (Linux, CI)       | Время (Windows) | Оценка объёма |
|---------------------------|------------------:|-------------------------:|----------------:|--------------:|
| `rand()`                  |     20 573.7 ms   | > 5 минут                | —               |       ~36.00  |
| `mt19937` + double        |     38 788.1 ms   | 156 s                    | 16 s            |     ~36.0003  |
| `mt19937` + float         |     28 258.4 ms   | 137 s                    | 9 s             |     ~35.9971  |
| **LCG (собственный)**     |  **4 440.6 ms**   | ~20 s                    | ~20 s           |     ~36.0025  |

Комментарий: `mt19937` кроссплатформенный и качественный, но медленнее; `rand()` зависит от OS (например, `RAND_MAX` в Windows = 32767), что влечёт повторы. **LCG** дал наилучший компромисс скорость/точность.
</details>

<details>
<summary><strong>Easy (π), 100 000 точек, 8 потоков, dynamic</strong></summary>

**`rand()`/`srand()`** (100 запусков):  
- Время: min **1.0839 ms**, mean **1.4924 ms**, median **1.44935 ms**, max **4.1153 ms**  
- Значение π: min **3.13308**, mean **3.13788**, median **3.13776**, max **3.14808**

**`mt19937` + `uniform_real_distribution`** (100 запусков):  
- Время: min **2.453 ms**, mean **3.312531 ms**, median **2.8652 ms**, max **44.2733 ms**  
- Значение π: min **3.13224**, mean **3.143149**, median **3.14274**, max **3.16036**
</details>

<details>
<summary><strong>100 000 000 точек (Easy), оптимальные настройки</strong></summary>

- Локально лучший режим: **8 потоков**, `schedule(dynamic, 2)`  
- 15 прогонов: среднее время **1381.27 ms**, средняя оценка π **3.14144**  
- При длинной серии прогонов смотреть на **минимальное** время (усталость/троттлинг CPU и прогрев кэшей искажают средние).
</details>

<details>
<summary><strong>Влияние числа потоков и вида schedule</strong></summary>

- `schedule(dynamic, 1)`: при росте потоков время **увеличивается** из‑за накладных расходов распределения крошечных чанков.  
- `schedule(static, 1)`: время **снижается** до числа аппаратных потоков (у CPU автора — 8), далее — рост.  
- `dynamic` vs `static`: при достаточно большом `chunk` `dynamic` иногда чуть быстрее (≈‑2%) за счёт лучшей балансировки.
</details>

### Эмпирическая формула для `chunk_size` (dynamic)

Для 8 потоков и `dynamic` (масштабируйте знаменатель на `max(1, numThreads)`):

```
chunk_size = max( 1,  2^{ceil(1.6 * log10(totalPoints))} / (8 * max(1, numThreads)) )
```

Идея: не делать чанки слишком мелкими (накладные расходы), но и не слишком крупными (потеря балансировки).
